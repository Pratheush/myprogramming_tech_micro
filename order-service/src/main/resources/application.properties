spring.application.name=ORDER-SERVICE

server.port=8087
#server.port=0

logging.level.com.mylearning.orderservice=error

spring.cloud.config.enabled=false
#spring.config.import=optional:configserver:http:'//localhost:8888
#spring.config.import=configserver:http:'//spring-cloud-config-server:8888

# if the Spring-Cloud-Config-Server is Down?
# after mentioning this code client will not run without getting configuration from Spring-Cloud-Config-Server. Default value is false
#spring.cloud.config.failFast=true
#spring.cloud.config.retry.max-attempts=15


spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.show_table=true
spring.jpa.hibernate.ddl-auto=validate
#spring.jpa.properties.hibernate.dialect=MySQL8Dialect
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect


#spring.datasource.url=jdbc:h2:mem:testdb
#persist the data
#spring.datasource.url=jdbc:h2:file:/home/pratheush/jlab/my_idea_projects/myprogramming_tech_micro/orderdb/orderdata
spring.datasource.url=jdbc:h2:file:./../../../../orderdb/orderdata
#spring.datasource.url=jdbc:h2:C:/data/sampledata
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.password=sa
spring.datasource.username=sa
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

#eureka.client.serviceUrl.defaultZone=http:'//localhost:8761/eureka
eureka.client.serviceUrl.defaultZone=http://eureka:password@localhost:8761/eureka

### resilience4j circuitbreaker ###
management.health.circuitbreakers.enabled=true
#management.endpoints.web.exposure.include=health
# Actuator Prometheus Endpoint all included
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

### resilience4j circuitbreaker ###
resilience4j.circuitbreaker.instances.unstablePlaceOrder.register-health-indicator=true
resilience4j.circuitbreaker.instances.unstablePlaceOrder.eventConsumerBufferSize=10
resilience4j.circuitbreaker.instances.unstablePlaceOrder.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.unstablePlaceOrder.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.unstablePlaceOrder.wait-duration-in-open-state=5s
resilience4j.circuitbreaker.instances.unstablePlaceOrder.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.instances.unstablePlaceOrder.sliding-window-type=COUNT_BASED
resilience4j.circuitbreaker.instances.unstablePlaceOrder.sliding-window-size=5

### resilience4j Timelimiter ###
resilience4j.timelimiter.instances.unstablePlaceOrder.timeout-duration=3s

### resilience4j Retry ### so if we don't get response in 5seconds it will retry for 4 times to call.
resilience4j.retry.instances.unstablePlaceOrder.max-attempts=3
resilience4j.retry.instances.unstablePlaceOrder.wait-duration=5s


### Distributed Tracing ###
# this sampler probability is 1.0 that means we want to send 100% of the request which we are receiving to our system to zipkin
# we want to start tracing 100% of the request which we are receiving to our system
spring.sleuth.sampler.probability=1.0
spring.zipkin.base-url=http:'//localhost:9411/


### Kafka Properties  ###
## These are the list of servers where we can find kafka
spring.kafka.bootstrap-servers=localhost:9092
## we are defining default topic name so that springboot will understand we have to always send the messages
spring.kafka.template.default-topic=notificationTopic
## providing information to our springboot project how to know serialize these key and value pair when sending to kafka broker right so we can define some serializers through spring kafka project
## using this property springboot will understand how we have to serialize this particular key and send it to the kafka broker
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
## we are defining the serializer for the value so its okey if we send orderPlacedEvent value as a json object to be able to convert this java object into a json
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer

# This property is important to add about mapping type .here trying to serialize the orderPlacedEvent and in notification-service whenever we receive this information from order-service
# we have to provide mapping type on site in the producer side and also consumer side
# on the producer side we will define what exactly is the type which we are sending for OrderPlacedEvent and on consumer side
# we will also define what is the exact type we are expecting . Here we are providing json type mapping as part of this json type mapping
# we are providing token value followed by the fully qualified class name of the body we are sending as part of the message
# the token value i have provided as some random value as event and followed by the fully qualified class name of the OrderPlacedEvent
# this way springboot will understand what is the json type mapping of the OrderPlacedEvent so we have to define the similar property at consumer side too.
# HERE TOKEN VALUE i.e. "event"  MUST BE SAME AT BOTH CONSUMER AND PRODUCER SIDE
spring.kafka.producer.properties.spring.json.type.mapping=event:com.mylearning.orderservice.event.OrderPlacedEvent



