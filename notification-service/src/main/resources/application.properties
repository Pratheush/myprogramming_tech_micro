
spring.application.name=NOTIFICATION-SERVICE

server.port=0

spring.cloud.config.enabled=false
#spring.config.import=optional:configserver:http:'//localhost:8888
#spring.config.import=configserver:http:'//spring-cloud-config-server:8888

# if the Spring-Cloud-Config-Server is Down?
# after mentioning this code client will not run without getting configuration from Spring-Cloud-Config-Server. Default value is false
#spring.cloud.config.failFast=true
#spring.cloud.config.retry.max-attempts=15

#configure Eureka URL for its own-discovery to other running Eureka-Naming-Server
# configuring the naming-server url in the application.properties of microservice application. to register microservice app properly with the naming-server
#eureka.client.serviceUrl.defaultZone=http:'//localhost:8761/eureka
eureka.client.serviceUrl.defaultZone=http://eureka:password@localhost:8761/eureka

### Distributed Tracing ###
# this sampler probability is 1.0 that means we want to send 100% of the request which we are receiving to our system to zipkin
# we want to start tracing 100% of the request which we are receiving to our system
spring.sleuth.sampler.probability=1.0
spring.zipkin.base-url=http://localhost:9411/
spring.sleuth.integration.enabled=true

# Kafka Properties
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.template.default-topic=notificationTopic

# illegal state exception no group id found in consumer config, kafkalistener or consumer container properties
# we have to define consumer group id on the consumer side
spring.kafka.consumer.group-id= notificationId

## we have defined serializer on the producers side because as we want to serialize according to the key and value pair
## and send it to the kafka broker and on the consumer side we have to deserialize the information like whatever the information
## is coming as part of the kafka broker we have to deserialize that read this information so for that we have to define
#  deserializer for key and value objects
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer

# token value as some random value here :: as event and we have fully-qualified class name of the OrderPlacedEvent
# This property is important to add about mapping type .here trying to serialize the orderPlacedEvent and in notification-service whenever we receive this information from order-service
# we have to provide mapping type on site in the producer side and also consumer side
# on the producer side we will define what exactly is the type which we are sending for OrderPlacedEvent and on consumer side
# we will also define what is the exact type we are expecting . Here we are providing json type mapping as part of this json type mapping
# we are providing token value followed by the fully qualified class name of the body we are sending as part of the message
# the token value i have provided as some random value as event and followed by the fully qualified class name of the OrderPlacedEvent
# this way springboot will understand what is the json type mapping of the OrderPlacedEvent so we have to define the similar property at consumer side too.
# HERE TOKEN VALUE i.e. "event"  MUST BE SAME AT BOTH CONSUMER AND PRODUCER SIDE
spring.kafka.consumer.properties.spring.json.type.mapping=event:com.mylearning.notificationservice.event.OrderPlacedEvent

# Actuator Prometheus Endpoint
#management.endpoints.web.exposure.include= prometheus

